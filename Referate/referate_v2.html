<!DOCTYPE html>
<html>
<head>
    <title>Cross-site scripting</title>
    <meta charset="UTF-8">
    <link rel="icon" type="image/x-icon" href="https://www.iconsdb.com/icons/preview/red/bug-xxl.png">
    <link rel="stylesheet" href="referate_v2.css">
</head>
<body id="home">
    <header>
        <h1>Уязвимости в уеб приложения - XSS - изпълнение на външни скриптове (OWASP-A7). Примери.</h1>
    </header>
    <nav>
        <a href="#home" class="nav"><b>Начало &#127968;</b></a>
        <a href="#xss" class="nav"><b>Какво е XSS? &#10067;</b></a>
        <a href="#types" class="nav"><b>Типове</b> &#128196;</a>
        <a href="#examples" class="nav"><b>Примери &#128172;</b></a>
        <a href="#security" class="nav"><b>Защита &#128274;</b></a>
        <a href="#references" class="nav"><b>Източници &#10145;</b></a>
    </nav>
    <img src="figure0.png" id="mainPic"/>
    <section id="xss">
        <h2>
            Какво е XSS атака?
        </h2>
        <p>
            Cross-Site Scripting атаката, или още наречена XSS, е вид уязвимост на сигурността, която може да
            бъде открита в някои уеб приложения. XSS атаките позволяват на
            <span class="hovertext" data-hover="Потребител, който умишлено осъществява достъп до система с намерението да причини вреда 
            на системата или да я използва по неоторизиран начин.">
                злонамерените потребители<sup>&#10067;</sup>
            </span> 
            да "инжектират"
            скриптове от страна на клиента в уеб страници, разглеждани от други потребители. Чрез намирането на начини 
            за инжектиране на злонамерени скриптове в уеб страници атакуващият може да получи допълнителни привилегии 
            за достъп до чувствително съдържание на страница - това могат да бъдат лични данни, сесийни
            <span class="hovertext" data-hover="Малки блокове от данни, които 
            се асоциират с дадено устройство, за по-бърз достъп до уебсайт.">
                бисквитки<sup>&#10067;</sup>
            </span> и друга информация, поддържана от браузъра.

            Терминът е измислен от специалистите по сигурност на Microsoft през януари 2000г. XSS уязвимостите
            са докладвани още през 90-те години на миналия век. Известни сайтове, засегнати от тази атака, са Twitter
            и Facebook. Превърнали са се в най-честата публично докладвана уязвимост на сигурността след аномалията
            buffer overflow (препълване на буфера). През 2007г. някои изследователи изчисляват, че 68% от уебсайтовете
            вероятно са отворени за междускриптови атаки. XSS уязвимостите, макар и най-често срещани в JavaScript, са 
            възможни и в CSS, Flash, VBScript и ActiveX. Според класация на Open Web Application Security Project (OWASP) -
            онлайн общност, която създава свободно достъпни статии, методологии, документация и технологии в областта на сигурност
            на уеб приложения, Cross-Site Scripting атаките се нареждат на 7-мо място от общо 10 по класацията за 
            най-разпространени рискове, свързани с уеб приложения. Новата класация от 2021 г. слага XSS уязвимостите
            в категория Injections (инжектиране на код) и ги нарежда на 3-то място.
        </p>
    </section>

    <section id="types">
        <h2>
            Типове
        </h2>
        <h3>
            Няма единна и стандартизирана класификация на XSS атаките, но повечето експерти разграничават няколко вида
            атаки:
        </h3>
        <ul>
            <li>Непостоянна (отразена)</li>
            <img src="https://miro.medium.com/max/720/1*K8ZoFFbgcrEoQroIyg2oxA.png" id="attacks">
            <p class="examples">Фигура 1: Пример за отразена XSS атака</p>
            <p>
            Отразената атака (известна още като XSS атака от първи ред) е най-разпространената разновидност на 
            междусайтови скриптове. Възниква, когато приложение получи данни в HTTP заявка и включва тези данни 
            във върнатия резултат по несигурен начин. В следващия пример е представена непостоянната XSS уязвимост:
            </p>
            <pre>
                <code>
                    https://insecure-website.com/status?message=All+is+well.
                    &lt;p&gt;Status: All is well.&lt;/p&gt;
                </code>
            </pre>
            <p>
            Тъй като приложението не извършва никаква обработка на данните, атакуващият може лесно да внедри
            атака като тази:
            </p>
            <pre>
                <code>
                    https://insecure-website.com/status?message=&lt;script&gt;/*+Bad+stuff+here...+*/&lt;/script&gt;
                    &lt;p&gt;Status: &lt;script&gt;/* Bad stuff here... */&lt;/script&gt;&lt;/p&gt;
                </code>
            </pre>
            <p>
            Ако потребителят кликне върху URL адреса, създаден от злонамерения хакер, тогава скриптът 
            ще се изпълни в браузъра на потребителя в контекста на сесията му с приложението. В този момент
            скриптът може да извърши всяко действие и да извлече всякакви данни, до които потребителят има достъп.
            </p>

            <li>Постоянна (съхранена)</li>
            <img src="https://miro.medium.com/max/720/1*5f7xNAvmOyl5G3Z1uL2OBA.png" id="attacks">
            <p class="examples">Фигура 2: Пример за съхранена XSS атака</p>
            <p>
            Постоянният XSS (известен още като XSS атака от втори ред) възниква, когато дадено приложение
            получи данни от ненадежден източник и ги включи в по-следващите отговори на HTTP заявка по
            несигурен начин. Въпросните данни могат да бъдат изпратени към приложението чрез HTTP заявки
            като например коментари към публикация в блог, потребителски псевдоними в стая за чат,
            данни за контакт при клиентска поръчка и др. В някои случаи данните могат да пристигнат 
            от други ненадеждни източници като приложение за уеб поща (ползващо <span class="hovertext" 
            data-hover="Интернет стандарт за пренос на електронна поща.">
                SMTP<sup>&#10067;</sup>
            </span> протокол), маркетингово
            приложение, показващо публикации в социални медии, приложение за наблюдение на мрежов трафик и др.
            Това е прост пример за съхранена XSS уязвимост. 
            Приложение за съобщения, позволяващо на потребителите да изпращат текст, който се показва и на 
            други потребители:
                <pre>
                    <code>
                        &lt;p&gt;Hello, this is my message!&lt;/p&gt;
                    </code>
                </pre>
                <p>
                Приложението не извършва никаква допълнителна обработва на данните, така че атакуващият може да
                изпрати съобщение, което да атакува други потребители:
                </p>
                <pre>
                    <code>
                        &lt;p&gt;&lt;script&gt;/* Bad stuff here... */&lt;/script&gt;&lt;/p&gt;
                    </code>
                </pre>
            </p>

            <li>DOM базирани XSS атаки</li>
            <img src="https://miro.medium.com/max/720/1*dd_vgKyfEh4raGjHMdURgw.png" id="attacks">
            <p class="examples">Фигура 3: Пример за DOM базирана XSS атака</p>
            <p>
            Този тип атаки възникват, когато дадено приложение съдържа клиентски JavaScript, който обработва данни
            от ненадежден източник по несигурен начин, обикновено чрез записване на данните обратно в DOM.
            В следващия пример е представено приложение, използващо JavaScript, който прочита стойност от поле за 
            въвеждане и я записва в елемент на HTML:
            </p>
            <pre>
                <code>
                    var search = document.getElementById('search').value;
                    var results = document.getElementById('results');
                    results.innerHTML = 'You searched for: ' + search;
                </code>
            </pre>
            <p>
                Ако атакуващият може да контролира стойността на полето за въвеждане, той може лесно да създаде
                злонамерена стойност, която да накара собствения му скрипт да се изпълни:
            </p>
            <pre>
                <code>
                    You searched for: &lt;img src=1 onerror='/* Bad stuff here... */'&gt;
                </code>
            </pre>

            <li>Mutated XSS (mXSS)</li>
            <p>
            Мутация на XSS се случва, когато атакуващият инжектира нещо, което изглежда безопасно, но е пренаписано
            и модифицирано от браузъра, докато се обработи от синтактичният анализатор. Това го прави изключително 
            трудно за откриване или дезинфекция в рамките на логиката на приложението на уебсайта. Типичен пример е 
            повторното балансиране на незатворени кавички или дори добавяне на кавички към параметри без кавички на 
            параметри към CSS font-family.
            </p>

            <li>Self-XSS</li>
            <p>
            Self-XSS е форма на XSS уязвимост, която разчита на 
            <span class="hovertext" data-hover="Психологическата манипулация на хора с цел извършване на действия 
            или разкриване на поверителна информация.">
                социално инженерство<sup>&#10067;</sup>
            </span>, за да подмами жертвата да изпълни 
            злонамерен JavaScript код в своя браузър. Въпреки че технически не е истинска XSS уязвимост, поради факта, 
            че разчита на социално инженерство на потребителя да изпълни код, а не на пропуск в засегнатия уебсайт, 
            позволяващ на атакуващ да го направи, тя все още крие същите рискове като обикновена XSS уязвимост, ако 
            се изпълни правилно.
            </p>
        </ul>
    </section>
    
    <section id="examples">
        <h2>
            Примери
        </h2>
        <h3>
            Междусайтовите скриптови атаки могат да възникнат навсякъде, където злонамерен потребител има правата да
            публикува нерегламентиран материал на доверен уебсайт, за да бъде достъпван от други потребители. Най-често
            срещаният пример може да се намери в уебсайтове с обяви, които предоставят Функционалност в стил уеб базиран
            пощенски списък.
        </h3>
        <ul>
            <li>
                Пример 1: Reflected XSS
                <img src="figure4.jpeg"/>
                <p class="examples">Фигура 4: Reflected XSS</p>
                <p>Следният кодов сегмент на <span class="hovertext" data-hover="Java Server Pages - колекция от технологии, 
                които позволяват на програмистите да създават динамични уеб страници, базирани на HTML, XML и др.
                ">
                    JSP<sup>&#10067;</sup>
                </span> чете ID на служител (eid) от HTTP заявка и го показва на потребителя:
                </p>
                <pre>
                    <code>
                        <% String eid = request.getParameter("eid"); %>
                        ...
                        Employee ID: <%= eid %>
                    </code>
                </pre>  
                <p>
                Кодът в примера работи правилно, ако eid съдържа само стандартен буквено-цифрен текст. Ако eid има
                стойност, която включва метасимволи или изходен код, тогава кодът ще бъде изпълнен от уеб браузъра, докато
                показва HTTP отговора. Първоначално това може да не изглежда като голяма уязвимост. В крайна сметка, защо 
                някой би въвел URL адрес, който кара зловреден код да се изпълнява на собствения му компютър? 
                Истинската опасност е нападателят да създаде злонамерения URL адрес, след което да използва имейл или 
                трикове за социално инженерство, за да примами жертвите да посетят подозрителна връзка към URL адреса. 
                Когато жертвите кликнат върху връзката, те несъзнателно отразяват злонамереното съдържание чрез 
                уязвимото уеб приложение обратно към собствените си компютри. Този механизъм за използване на 
                уязвими уеб приложения е известен като Reflected XSS.
                </p>
            </li>

            <li>
                Пример 2: Stored XSS
                <img src="https://media.geeksforgeeks.org/wp-content/uploads/20190516152959/Cross-Site-ScriptingXSS.png"/>
                <p class="examples">Фигура 5: Stored XSS</p>
                <p>
                Следният кодов сегмент на JSP изпраща заявка към база от данни за служител с даден идентификатор и 
                отпечатва името на съответния служител:
                </p>
                <pre>
                    <code>
                        <%...
                            Statement stmt = conn.createStatement();
                            ResultSet rs = stmt.executeQuery("select * from emp where id="+eid);
                            if (rs != null) {
                            rs.next();
                            String name = rs.getString("name");
                        %>

                        Employee Name: <%= name %>
                    </code>
                </pre>
                <p>
                Ако стойността на name идва от потребителски данни, тогава базата от данни може да стане канал за
                злонамерено съдържание. Този тип уязвимост, известна като Stored XSS, е опасна, защото хранилището на
                данни създава индиректност, което прави по-трудно идентифицирането на заплахата и увеличава възможността
                атаката да засегне много потребители.
                </p>
            </li>

            <li>
                Пример 3: DOM XSS
                <p>Нека разгледаме следния код:</p>
                <pre>
                    <code>
                        &lt;html&gt;
                            &lt;head&gt;
                            &lt;title&gt;Custom Dashboard &lt;/title&gt;
                            ...
                            &lt;/head&gt;
                            Main Dashboard for
                            &lt;script&gt;
                                var pos = document.URL.indexOf("context=") + 8;
                                document.write(document.URL.substring(pos,document.URL.length));
                            &lt;/script&gt;
                            ...
                        &lt;/html&gt;
                    </code>                                                                 
                </pre>
                <p>
                    Страницата "http://www.example.com/userdashboard.html" се персонализира въз основа на потребителското име,
                    което е кодирано в URL адреса. Ако потребителят е Mary, адресът ще се промени на "http://www.example.com/userdashboard.html?context=Mary".
                    Сега можем да погледнем следния сценарий за DOM-базирана междускриптова атака:
                </p>
                <ol>
                    <li>Нападателят вгражда злонамерения скрипт в URL линка: "http://www.example.com/userdashboard.html#context=&lt;script&gt;SomeFunction(somevariable)&lt;/script&gt;".</li>
                    <li>Браузърът на жертвата получава този линк, изпраща HTTP заявка към "http://www.example.com" и получава статичната HTML страница</li>
                    <li>Браузърът започва изграждане на DOM дървото на страницата и попълва свойството document.URL с адреса от стъпка 1.</li>
                    <li>Браузърът анализира HTML страницата, стига до скрипта и го изпълнява, извличайки злонамереното съдържание от свойството document.URL.</li>
                    <li>Браузърът актуализира основния текст на HTML страницата и той изглежда така: "Main Dashboard for &lt;script&gt;SomeFunction(somevariable)&lt;/script&gt;".</li>
                    <li>Браузърът намира JavaScript кода в тялото на HTML и го изпълнява.</li>
                </ol>
                <p>
                В реалността атакуващият би кодирал текста така, че да не бъде очевидно съдържанието на скрипт. Някои 
                браузъри могат да кодират знаците &lt; и &gt; в URL адреса, което може да спре някои атаки. Съществуват
                обаче сценарии, при които злонамереният код не съдържа тези знаци, от което следва, че и тези браузъри 
                не са напълно имунизирани срещу DOM XSS.
                </p>
            </li>

            <li>
                Пример 4: Mutated XSS
                <p>
                    В следния код е използвана библиотеката <span class="hovertext" 
                    data-hover="Библиотека, написана на JavaScript, която позволява по-лесно да се манипулират DOM дървото, събития, ефекти, анимации и др.">
                        jQuery<sup>&#10067;</sup>
                    </span> и е пример как стандартен браузър интерпретира невалиден HTML:
                <pre>
                    <code>
                        $('body').innerHTML = '&lt;div&gt;&lt;a title=”&lt;/div”&gt;'
                    </code>                                                                 
                </pre>
                </p>
                <p>Браузърът ще модифицира данните така, че да направи валиден HTML кода. Той ще изглежда така:</p>
                <pre>
                    <code>
                        &lt;div&gt;
                            &lt;a title="”&lt;/div"&gt;”&lt;/a&gt;
                        &lt;/div&gt;
                    </code>
                </pre>
                <p>Ако на мястото на тага div сложим тага style:</p>
                <pre>
                    <code>
                        $('body').innerHTML = '&lt;style&gt;&lt;a title=”&lt;/style”&gt;'
                    </code>
                </pre>
                <p>Ще генерираме следния изход:</p>
                <pre>
                    <code>
                        &lt;style&gt;
                            &lt;a title="”&lt;/div"&gt;”&lt;/a&gt;
                        &lt;/style&gt;
                    </code>
                </pre>
                <p>
                Двата примера не действат еднакво, защото информацията в таговете се анализира по различен начин
                в зависимост от типа на тага. Вървейки отляво надясно, синтактичния анализатор в първия случай отваря
                &lt;div&gt; таг, след това таг &lt;a&gt; с атрибут "title" и тъй като затварящият &lt;div&gt; таг е 
                текст, написан в атрибута на тага &lt;a&gt;, той няма да се затвори. Във втория случай, когато 
                анализаторът мине през тага &lt;style&gt;, той се превръща в CSS-базиран анализатор и затваря тага 
                там, където трябва.
                </p>
            </li>
        </ul>
    </section>

    <section id="security">
        <h2>
            Защита
        </h2>
        <img src="https://www.security.org/app/uploads/2020/12/digital-security-image.png">
        <p class="examples">Фигура 6: Security</p>
        <h3>
            Посредством зловреден JavaScript, инжектиран в браузъра, могат да бъдат реализирани следните атаки:
        </h3>
        <ul>
            <li>
                Кражба на сесията (Session Hijacking)
                <p>HTTP бисквитките могат да бъдат достъпени чрез JavaScript и по този начин могат да се манипулират 
                данни и да се поемат цели сесии.</p>
            </li>
            <li>
                Щракване (Clickjacking)
                <p>Mоже да се инициира скрито щракване с мишката на жертвата, за да се извършат злонамерени действия
                като поръчки, верификации и др.</p>
            </li>
            <li>
                Подправяне на съдържание (Content Spoofing)
                <p>JavaScript има пълен достъп до клиентския код на уебсайта, затова може да
                показва и променя всяко съдържание.</p>
            </li>
            <li>
                Принудително изтегляне на софтуер (Forced Downloads)
                <p>По-лесно е да се тегли злонамерен софтуер от уж доверен уебсайт.</p>
            </li>
            <li>
                Крипто копаене (Crypto Mining)
                <p>Централният процесор на жертвата може да бъде използван за злоупотреба с процесорна мощ.</p>
            </li>
            <li>
                Регистриране на натиснати клавиши (Keylogger)
                <p>Могат да се четат записите от клавиатурата на съответния браузър.</p>
            </li>
            <li>
                Запис на аудио и уеб камера (Record Audio and Webcam)
                <p>Изисква оторизация на потребителя и след това микрофонът и/или уеб камерата на жертвата могат да 
                станат достъпни.</p>
            </li>
            <li>
                Мрежово сканиране (Network Scanning)
                <p>Браузърът на жертвата може да бъде злоупотребен, за да сканира портове и хостове с JavaScript.</p>
            </li>
            <li>
                Отказ от услуга (DoS)
                <p>Браузърът на жертвата може несъзнателно да участва в <span class="hovertext" 
                    data-hover="Хакерска атака за отказ от услуга, която цели да направи даден сървър недостъпен за потребителите му.">
                        DDoS<sup>&#10067;</sup>
                    </span> атака срещу някой сървър.
                </p>
            </li>
        </ul>

        <h3>
            За предотвратяване на злонамерена дейност е препоръчително да се спазват някои практики за защита:
        </h3>
        <ul>
            <li>Контекстно изходно кодиране/изключване на входен низ</li>
            <p>
            Съществуват няколко схеми: <span class="hovertext" data-hover="Процес на изпращане на информацията на 
            даден сървър така, че текстът да бъде визуализиран като текст, а не като HTML код.">
                кодиране<sup>&#10067;</sup>
            </span> на HTML обект, филтриране на JavaScript, филтриране на CSS и кодиране на URL.
            Повечето от уеб сайтовете, които не обработват чувствителна информация, могат да използват филтриране, за да елиминират
            до голяма степен риска от XSS атаки по доста лесен начин.
            </p>

            <li>Безопасно валидиране на ненадежден HTML код</li>
            <p>
            Някои уеб приложения като форуми и уеб поща позволяват на потребителите да използват ограничено подмножество
            от HTML маркиране. Ако например имаме вход от потребителя &lt;b&gt;very&lt;/b&gt; large, кодиране от типа
            &amp;lt;b&amp;gt;very&amp;lt;/b&amp;gt; large няма да бъде достатъчно, тъй като ще бъде изобразено като "very large", а не
            като &lt;b&gt;very&lt;/b&gt; large.
            Много от валидациите разчитат на анализ на специфични HTML тагове, каквито са &lt;script&gt;, &lt;link&gt; и &lt;iframe&gt;,
            но съществуват няколко проблема с този подход. Например понякога привидно безобидни тагове могат да бъдат
            пропуснати, което може да доведе до XSS атака: &lt;img src="javascript:alert(1)"&gt; или 
            &lt;body background="javascript:alert("XSS")"&gt;&lt;/body&gt;. Друг популярен метод е да се премахне въведеното от 
            потребителя "and", но това също може да бъде заобиколено от злонамерените потребители чрез обфускация 
            (умишлено използване на объркващ и двусмислен език при съобщения).
            </p>

            <li>Сигурност на бисквитки</li>
            <p>
            Много от уеб приложенията разчитат на сесийни бисквитки за удостоверяване между отделни HTTP заявки и т.к.
            скриптовете от страна на клиента обикновено имат достъп до тези бисквитки, прости XSS 
            <span class="hovertext" data-hover="Софтуер, който се възползва от грешка или уязвимост на дадена система, 
            за да причини вреда или нежелано поведение.">
                експлойти<sup>&#10067;</sup>
            </span> могат да ги откраднат.
            Макар и да не може да се предотврати проблемът напълно, той може да се смекчи. Много от уеб приложенията свързват
            сесийните бисквитки с IP адреса на потребителя, който първоначално е влязъл, и след това позволяват единствено на него
            да използва тази бисквитка. Ефективно е, ако нападателят търси само бисквитката, но ако той стои зад същия
            IP адрес или прокси като своята жертва, защитата става неефективна.
            </p>
    
            <li>Деактивиране на скриптове</li>
            <p>
            Някои браузъри или добавки за браузъри могат да бъдат конфигурирани да деактивират скриптове от страна на 
            клиента на базата на някакъв домейн. Функционалността, която блокира всички скриптове и външни включвания
            по подразбиране и след това позволява на потребителя да я активира на базата на домейн, е възможна от версия 4
            на Internet Explorer и версия 9 на Opera. Най-значимият проблем с това блокиране е, че значително се намалява
            функционалността и отзивчивостта, т.е. скриптовете от страна на клиента могат да бъдат много по-бързи от скриптовете
            от страна на сървъра. Други проблеми с този подход са, че много от потребителите не разбират и не знаят как правилно
            да защитят своите браузъри и това, че много сайтове не работят без скриптове от страна на клиента, което принуждава
            потребителите да деактивират защитата за съответния сайт и така отварят системите си за уязвимости.
            </p>

            <li>Селективно деактивиране на скриптове</li>
            <p>
            Content-Security-Policy (CSP) или т.н. политика за сигурност на съдържанието, позволява на HTML документите
            да се включат за деактивиране на някои скриптове, докато оставят други активирани. Преди да реши да го изпълни, 
            браузърът проверява всеки скрипт спрямо конкретни правила. Статистиката показва обаче, че 94.68% от политиките, които
            се опитват да ограничат изпълнението на скриптове са, неефективни и че 99.34% от хостовете с CSP използват политики,
            които не предлагат никаква защита срещу XSS атаки.
            </p>
        </ul>

    <section id="references">
        <h2>
            Източници
        </h2>
        <ul id="refs">
            <li>Връзки:</li>
            <li>[1] Wikipedia, <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">https://en.wikipedia.org/wiki/Cross-site_scripting</a>, последно посетен на 24.11.2022</li>
            <li>[2] KirstenS, <a href="https://owasp.org/www-community/attacks/xss/">https://owasp.org/www-community/attacks/xss/</a>, последно посетен на 24.11.2022</li>
            <li>[3] OWASP, <a href="https://owasp.org/www-community/Types_of_Cross-Site_Scripting">https://owasp.org/www-community/Types_of_Cross-Site_Scripting</a>, последно посетен на 24.11.2022</li>
            <li>[4] PortSwigger, <a href="https://portswigger.net/web-security/cross-site-scripting">https://portswigger.net/web-security/cross-site-scripting</a>, последно посетен на 24.11.2022</li>
            <li>[5] W3schools, <a href="https://www.w3schools.com/cybersecurity/cybersecurity_web_applications_attacks.php">https://www.w3schools.com/cybersecurity/cybersecurity_web_applications_attacks.php</a>, последно посетен на 24.11.2022</li>
            <li>[6] Acunetix, <a href="https://www.acunetix.com/websitesecurity/cross-site-scripting/">https://www.acunetix.com/websitesecurity/cross-site-scripting/</a>, последно посетен на 24.11.2022</li>
            <li>[7] Jan Kahmen, <a href="https://turingpoint.de/en/blog/xss-overview-definition-and-case-studies/">https://turingpoint.de/en/blog/xss-overview-definition-and-case-studies/</a>, последно посетен на 24.11.2022</li>
            <li>[8] Ayush Verma, <a href="https://javascript.plainenglish.io/website-security-a-comprehensive-guide-3888684afac6">https://javascript.plainenglish.io/website-security-a-comprehensive-guide-3888684afac6</a>, последно посетен на 24.11.2022</li>
            <li>[9] Erez Yalon, <a href="https://securityboulevard.com/2020/07/mutation-cross-site-scripting-mxss-vulnerabilities-discovered-in-mozilla-bleach/">https://securityboulevard.com/2020/07/mutation-cross-site-scripting-mxss-vulnerabilities-discovered-in-mozilla-bleach/</a>, последно посетен на 22.12.2022</li>
        </ul>
        <ul id="refs">
            <li>Фигури:</li>
            <li>[1] <a href="https://blog.scottlogic.com/rsillem/assets/security-xss/reflected-xss.png">https://blog.scottlogic.com/rsillem/assets/security-xss/reflected-xss.png</a></li>
            <li>[2] <a href="https://blog.scottlogic.com/rsillem/assets/security-xss/stored-xss.png">https://blog.scottlogic.com/rsillem/assets/security-xss/stored-xss.png</a></li>
            <li>[3] <a href="https://blog.scottlogic.com/rsillem/assets/security-xss/DOM-based-xss.png">https://blog.scottlogic.com/rsillem/assets/security-xss/DOM-based-xss.png</a></li>
            <li>[4] <a href="https://miro.medium.com/max/720/1*KGAppeqpUwv8OgPKkT0Ujw.webp">https://miro.medium.com/max/720/1*KGAppeqpUwv8OgPKkT0Ujw.webp</a></li>
            <li>[5] <a href="https://media.geeksforgeeks.org/wp-content/uploads/20190516152959/Cross-Site-ScriptingXSS.png">https://media.geeksforgeeks.org/wp-content/uploads/20190516152959/Cross-Site-ScriptingXSS.png</a></li>
            <li>[6] <a href="https://www.security.org/app/uploads/2020/12/digital-security-image.png">https://www.security.org/app/uploads/2020/12/digital-security-image.png</a></li>
        </ul>
    </section>

    <footer>
        <p id="footer">Автор: Дони Иванов, ФН: 81992 &#128102;<br>
        <a href="mailto:fn81992@g.fmi.uni-sofia.bg" id="email">fn81992@g.fmi.uni-sofia.bg &#128231;</a></p>
    </footer>
</body>
</html>